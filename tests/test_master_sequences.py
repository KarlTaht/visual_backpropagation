#!/usr/bin/env python3
"""
Comprehensive test suite for master sequence functionality.
Tests various configurations and verifies correctness.

Run with: pytest __tests__/test_master_sequences.py -v
"""

import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from dataset import SequenceDataset
import numpy as np
import pytest


@pytest.fixture
def base_config():
    """Base configuration for all tests."""
    return {
        'vocabulary': ['a', 'b', 'c', 'd'],
        'sequence_length': 5,
        'encoding_type': 'one_hot',
        'task_type': 'next_token'
    }


def verify_subsequence_in_master(subsequence, master_sequences):
    """
    Verify that a subsequence exists in at least one master sequence.

    Args:
        subsequence: List of tokens forming a subsequence
        master_sequences: List of master sequences to check against

    Returns:
        bool: True if subsequence is found in any master sequence
    """
    subseq_str = ''.join(subsequence)

    for master_seq in master_sequences:
        master_str = ''.join(master_seq)
        if subseq_str in master_str:
            return True

    return False


def decode_sequence_from_onehot(X_sample, vocab_size, sequence_length):
    """
    Decode a one-hot encoded sequence back to token list.

    Args:
        X_sample: One-hot encoded input (flattened)
        vocab_size: Size of vocabulary
        sequence_length: Length of sequence (for next_token, this is seq_len - 1)

    Returns:
        List of token indices
    """
    tokens = []
    for i in range(sequence_length):
        chunk = X_sample[i * vocab_size : (i + 1) * vocab_size]
        token_idx = np.argmax(chunk)
        tokens.append(token_idx)
    return tokens


def verify_all_samples_are_subsequences(dataset, master_sequences, vocab):
    """
    Helper function to verify all training samples are valid subsequences.

    Args:
        dataset: The SequenceDataset instance
        master_sequences: List of master sequences to check against
        vocab: List of vocabulary tokens

    Returns:
        Number of valid samples found
    """
    vocab_size = len(vocab)
    seq_len = dataset.sequence_length
    idx_to_token = {idx: token for idx, token in enumerate(vocab)}

    valid_count = 0
    for i in range(dataset.num_samples):
        X_sample = dataset.X[i]
        y_sample = dataset.y[i]

        input_tokens_idx = decode_sequence_from_onehot(X_sample, vocab_size, seq_len - 1)
        target_token_idx = np.argmax(y_sample)

        input_tokens = [idx_to_token[idx] for idx in input_tokens_idx]
        target_token = idx_to_token[target_token_idx]

        full_sequence = input_tokens + [target_token]

        if verify_subsequence_in_master(full_sequence, master_sequences):
            valid_count += 1

    return valid_count


def test_explicit_master_sequences(base_config):
    """Test explicit master sequences with fixed sequences."""
    config = {
        **base_config,
        'num_samples': 30,
        'master_sequences': [
            ['a', 'b', 'c', 'c', 'a', 'a', 'b', 'b'],  # Length 8
            ['a', 'd', 'd', 'a', 'c', 'c', 'a', 'd']   # Length 8
        ]
    }

    dataset = SequenceDataset(config)
    info = dataset.get_info()

    # Verify master sequences exist and have correct properties
    assert info['master_sequences'] is not None
    assert info['master_sequences']['num_sequences'] == 2
    assert info['master_sequences']['sequence_lengths'] == [8, 8]

    # Verify all training samples are subsequences of master sequences
    valid_count = verify_all_samples_are_subsequences(
        dataset,
        config['master_sequences'],
        config['vocabulary']
    )
    assert valid_count == info['num_samples'], \
        f"Only {valid_count}/{info['num_samples']} samples are valid subsequences"


def test_autogenerated_master_sequences_range(base_config):
    """Test auto-generated master sequences with length range."""
    config = {
        **base_config,
        'num_samples': 30,
        'num_master_sequences': 4,
        'master_sequence_length': (10, 15)  # Range [10, 15]
    }

    dataset = SequenceDataset(config)
    info = dataset.get_info()

    # Verify master sequences exist
    assert info['master_sequences'] is not None
    assert info['master_sequences']['num_sequences'] == 4

    # Verify all lengths are in range [10, 15]
    actual_lengths = info['master_sequences']['sequence_lengths']
    for length in actual_lengths:
        assert 10 <= length <= 15, f"Master sequence length {length} not in range [10, 15]"

    # Verify all training samples are subsequences of master sequences
    valid_count = verify_all_samples_are_subsequences(
        dataset,
        info['master_sequences']['sequences'],
        config['vocabulary']
    )
    assert valid_count == info['num_samples'], \
        f"Only {valid_count}/{info['num_samples']} samples are valid subsequences"


def test_autogenerated_master_sequences_fixed(base_config):
    """Test auto-generated master sequences with fixed length."""
    config = {
        **base_config,
        'num_samples': 20,
        'num_master_sequences': 3,
        'master_sequence_length': 12  # Fixed length
    }

    dataset = SequenceDataset(config)
    info = dataset.get_info()

    # Verify master sequences exist
    assert info['master_sequences'] is not None
    assert info['master_sequences']['num_sequences'] == 3

    # Verify all lengths are exactly 12
    actual_lengths = info['master_sequences']['sequence_lengths']
    for length in actual_lengths:
        assert length == 12, f"Master sequence length {length} != 12"

    # Verify subsequences
    valid_count = verify_all_samples_are_subsequences(
        dataset,
        info['master_sequences']['sequences'],
        config['vocabulary']
    )
    assert valid_count == info['num_samples'], \
        f"Only {valid_count}/{info['num_samples']} samples are valid subsequences"


def test_no_master_sequences(base_config):
    """Test fully random generation without master sequences."""
    config = {
        **base_config,
        'num_samples': 20
        # No master sequence parameters
    }

    dataset = SequenceDataset(config)
    info = dataset.get_info()

    # Verify no master sequences
    assert info['master_sequences'] is None

    # Verify dataset was generated successfully
    assert info['num_samples'] == 20
    assert dataset.X.shape == (20, 16)  # 4 tokens * 4 positions
    assert dataset.y.shape == (20, 4)   # 4-dim one-hot target
